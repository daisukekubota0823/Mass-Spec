<?xml version="1.0" encoding="utf-8" ?>
<Comments>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs">
    <code>                ElectronDonation model = ElectronDonation.DaylightModel;
                ICycleFinder cycles = Cycles.Or(Cycles.AllSimpleFinder, Cycles.GetAllFinder(6));
                Aromaticity aromaticity = new Aromaticity(model, cycles);

                // apply our configured model to each molecule
                foreach (IAtomContainer molecule in molecules)
                {
                    aromaticity.Apply(molecule);
                }
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs+ctor">
    <code>                // mimics the CDKHuckelAromaticityDetector
                Aromaticity aromaticity_cdk = new Aromaticity(ElectronDonation.CDKModel, Cycles.CDKAromaticSetFinder);
                // mimics the DoubleBondAcceptingAromaticityDetector
                Aromaticity aromaticity_exo = new Aromaticity(ElectronDonation.CDKAllowingExocyclicModel, Cycles.CDKAromaticSetFinder);
                // a good model for writing SMILES
                Aromaticity aromaticity_smi = new Aromaticity(ElectronDonation.DaylightModel, Cycles.AllSimpleFinder);
                // a good model for writing MDL/Mol2
                Aromaticity aromaticity_mdl = new Aromaticity(ElectronDonation.PiBondsModel, Cycles.AllSimpleFinder);
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs+FindBonds">
    <code>                Aromaticity aromaticity = new Aromaticity(ElectronDonation.CDKModel, Cycles.AllSimpleFinder);
                IAtomContainer container = TestMoleculeFactory.MakeAnthracene();
                AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(container);
                try
                {
                    var bonds = aromaticity.FindBonds(container);
                    int nAromaticBonds = bonds.Count();
                }
                catch (CDKException)
                {
                    // cycle computation was intractable
                }
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs+Apply">
    <code>                Aromaticity aromaticity = new Aromaticity(ElectronDonation.CDKModel, Cycles.AllSimpleFinder);
                IAtomContainer container = TestMoleculeFactory.MakeAnthracene();
                try
                {
                    if (aromaticity.Apply(container))
                    {
                        //
                    }
                }
                catch (CDKException)
                {
                    // cycle computation was intractable
                }
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs+CDKLegacy_CDKAromaticSetFinder">
    <code>                new Aromaticity(ElectronDonation.CDKModel, Cycles.CDKAromaticSetFinder);
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.Aromaticity_Example.cs+CDKLegacy_AllFinder_RelevantFinder">
    <code>                new Aromaticity(ElectronDonation.CDKModel, Cycles.Or(Cycles.AllSimpleFinder, Cycles.RelevantFinder));
</code>
  </Codes>
  <Codes id="NCDK.Aromaticities.ElectronDonation_Example.cs">
    <code>                ElectronDonation model = ElectronDonation.CDKModel;
</code>
  </Codes>
  <Codes id="NCDK.Charges.MMFF94PartialCharges_Example.cs">
    <code>            SmilesParser sp = new SmilesParser();
            IAtomContainer ac = sp.ParseSmiles("CC");
            AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(ac);
            AtomContainerManipulator.ConvertImplicitToExplicitHydrogens(ac);
            MMFF94PartialCharges mmff = new MMFF94PartialCharges();
            mmff.AssignMMFF94PartialCharges(ac);
</code>
  </Codes>
  <Codes id="NCDK.Charges.MMFF94PartialCharges_Example.cs+result">
    <code>                    atom.GetProperty&lt;double&gt;("MMFF94charge")
</code>
  </Codes>
  <Codes id="NCDK.Config.AtomTypeFactory_Example.cs+1">
    <code>                AtomTypeFactory factory = AtomTypeFactory.GetInstance();
</code>
  </Codes>
  <Codes id="NCDK.Config.AtomTypeFactory_Example.cs+2">
    <code>                AtomTypeFactory factory = AtomTypeFactory.GetInstance("NCDK.Config.Data.jmol_atomtypes.txt");
</code>
  </Codes>
  <Codes id="NCDK.Config.ChemicalElement_Example.cs+OfNumber">
    <code>                // carbon
                var c = ChemicalElement.Of(6);
                // oxygen
                var o = ChemicalElement.Of(8);
</code>
  </Codes>
  <Codes id="NCDK.Config.ChemicalElement_Example.cs+ToAtomicNumber">
    <code>                var a = ChemicalElement.OfSymbol("c").AtomicNumber;
                var b = ChemicalElement.OfSymbol("C").AtomicNumber;
                var c = ChemicalElement.OfSymbol("Carbon").AtomicNumber;
                var d = ChemicalElement.OfSymbol("carbon").AtomicNumber;
</code>
  </Codes>
  <Codes id="NCDK.Config.XMLIsotopeFactory_Example.cs+1">
    <code>                IsotopeFactory ifac = XMLIsotopeFactory.Instance;
</code>
  </Codes>
  <Codes id="NCDK.Config.XMLIsotopeFactory_Example.cs+example">
    <code>                IsotopeFactory factory = XMLIsotopeFactory.Instance;
                IIsotope major = factory.GetMajorIsotope("H");
</code>
  </Codes>
  <Codes id="NCDK.Depict.Abbreviations_Example.cs">
    <code>            Abbreviations abrv = new Abbreviations
            {
                // add some abbreviations, when overlapping (e.g. Me,Et,tBu) first one wins
                "[Na+].[H-] NaH",
                "*c1ccccc1 Ph",
                "*C(C)(C)C tBu",
                "*CC Et",
                "*C Me"
            };
            // maybe we don't want 'Me' in the depiction
            abrv.SetEnabled("Me", false);
            // assign abbreviations with some filters
            int numAdded = abrv.Apply(mol);
            // generate all but don't assign, need to be added manually
            // set/update the CDKPropertyName.CtabSgroups property of mol
            var sgroups = abrv.Generate(mol);
</code>
  </Codes>
  <Codes id="NCDK.Depict.Abbreviations_Example.cs+1">
    <code>            // https://www.github.com/openbabel/superatoms
            abrv.LoadFromFile("obabel_superatoms.smi");
</code>
  </Codes>
  <Codes id="NCDK.Depict.DepictionGenerator_Example.cs+1">
    <code>                DepictionGenerator dg = new DepictionGenerator()
                {
                    Size = new Size(512, 512),
                    AtomColorer = new Renderers.Colors.CDK2DAtomColors(),
                };
                foreach (IAtomContainer mol in mols)
                    dg.Depict(mol).WriteTo("mol.png");
</code>
  </Codes>
  <Codes id="NCDK.Depict.DepictionGenerator_Example.cs+2">
    <code>                new DepictionGenerator().Depict(mol).WriteTo("mol.png");
</code>
  </Codes>
  <Codes id="NCDK.Depict.DepictionGenerator_Example.cs+3">
    <code>                Depiction depiction = new DepictionGenerator().Depict(mol);
                 
                // quick use, format determined by name by path
                depiction.WriteTo("mol.png");
                depiction.WriteTo("mol.svg");
                depiction.WriteTo("mol.pdf");
                depiction.WriteTo("mol.jpg");
                 
                // manually specify the format
                depiction.WriteTo(Depiction.SvgFormatKey, "~/mol");

                // convert to a Java buffered image
                RenderTargetBitmap img = depiction.ToBitmap();

                // get the SVG XML string
                string svg = depiction.ToSvgString();
</code>
  </Codes>
  <Codes id="NCDK.Depict.Depiction_Example.cs+EnsureSuffix">
    <code>            depiction.WriteTo(Depiction.SvgFormatKey, "~/chemical"); // create a file "~/chemical.svg" 
</code>
  </Codes>
  <Codes id="NCDK.Depict.SvgDrawVisitor_Example.cs">
    <code>            SvgDrawVisitor visitor = new SvgDrawVisitor(50, 50, Depiction.UnitsMM);
            visitor.Visit(renderingElements);
            string svg = visitor.ToString();
</code>
  </Codes>
  <Codes id="NCDK.Fingerprints.FingerprinterTool_Example.cs+IsSubset">
    <code>                var mol = TestMoleculeFactory.MakeIndole();
                var fingerprinter = new Fingerprinter();
                var bs = fingerprinter.GetBitFingerprint(mol);
                var frag1 = TestMoleculeFactory.MakePyrrole();
                var bs1 = fingerprinter.GetBitFingerprint(frag1);
                if (FingerprinterTool.IsSubset(bs.AsBitSet(), bs1.AsBitSet()))
                {
                    Console.Out.WriteLine("Pyrrole is subset of Indole.");
                }
</code>
  </Codes>
  <Codes id="NCDK.Fingerprints.Fingerprinter_Example.cs">
    <code>                var molecule = new AtomContainer();
                var fingerprinter = new Fingerprinter();
                var fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Length); // returns 1024 by default
</code>
  </Codes>
  <Codes id="NCDK.Fingerprints.HybridizationFingerprinter_Example.cs">
    <code>                var molecule = new AtomContainer();
                var fingerprinter = new HybridizationFingerprinter();
                var fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Length); // returns 1024 by default
</code>
  </Codes>
  <Codes id="NCDK.Fingerprints.PubchemFingerprinter_Example.cs">
    <code>                var molecule = new AtomContainer();
                IFingerprinter fingerprinter = new PubchemFingerprinter();
                IBitFingerprint fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Length); // returns 881
</code>
  </Codes>
  <Codes id="NCDK.Fingerprints.ShortestPathFingerprinter_Example.cs">
    <code>                var molecule = new AtomContainer();
                AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(molecule);
                var fingerprinter = new ShortestPathFingerprinter();
                var fingerprint = fingerprinter.GetBitFingerprint(molecule);
                Console.WriteLine(fingerprint.Length); // returns 1024 by default
</code>
  </Codes>
  <Codes id="NCDK.ForceFields.MmffAtomTypeMatcher_Example.cs">
    <code>            MmffAtomTypeMatcher mmffAtomTypes = new MmffAtomTypeMatcher();
            foreach (var container in containers)
            {
                string[] symbs = mmffAtomTypes.SymbolicTypes(container);
            }
</code>
  </Codes>
  <Codes id="NCDK.ForceFields.Mmff_Example.cs">
    <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                Mmff mmff = new Mmff();
                mmff.AssignAtomTypes(mol);
                mmff.PartialCharges(mol);
                mmff.ClearProps(mol); // optional
</code>
  </Codes>
  <Codes id="NCDK.Formula.FullEnumerationFormulaGenerator_Example.cs">
    <code>            var ifac = BODRIsotopeFactory.Instance;
            IIsotope c = ifac.GetMajorIsotope("C");
            IIsotope h = ifac.GetMajorIsotope("H");
            IIsotope n = ifac.GetMajorIsotope("N");
            IIsotope o = ifac.GetMajorIsotope("O");
            IIsotope p = ifac.GetMajorIsotope("P");
            IIsotope s = ifac.GetMajorIsotope("S");

            MolecularFormulaRange mfRange = new MolecularFormulaRange();
            mfRange.AddIsotope(c, 0, 50);
            mfRange.AddIsotope(h, 0, 100);
            mfRange.AddIsotope(o, 0, 50);
            mfRange.AddIsotope(n, 0, 50);
            mfRange.AddIsotope(p, 0, 10);
            mfRange.AddIsotope(s, 0, 10);

            double minMass = 133.003;
            double maxMass = 133.005;
            MolecularFormulaGenerator mfg = new MolecularFormulaGenerator(builder, minMass, maxMass, mfRange);
            IMolecularFormulaSet mfSet = mfg.GetAllFormulas();
</code>
  </Codes>
  <Codes id="NCDK.Formula.MolecularFormulaGenerator_Example.cs">
    <code>            var ifac = BODRIsotopeFactory.Instance;
            IIsotope c = ifac.GetMajorIsotope("C");
            IIsotope h = ifac.GetMajorIsotope("H");
            IIsotope n = ifac.GetMajorIsotope("N");
            IIsotope o = ifac.GetMajorIsotope("O");
            IIsotope p = ifac.GetMajorIsotope("P");
            IIsotope s = ifac.GetMajorIsotope("S");

            MolecularFormulaRange mfRange = new MolecularFormulaRange();
            mfRange.AddIsotope(c, 0, 50);
            mfRange.AddIsotope(h, 0, 100);
            mfRange.AddIsotope(o, 0, 50);
            mfRange.AddIsotope(n, 0, 50);
            mfRange.AddIsotope(p, 0, 10);
            mfRange.AddIsotope(s, 0, 10);

            var builder = Silent.ChemObjectBuilder.Instance;
            double minMass = 133.003;
            double maxMass = 133.005;
            MolecularFormulaGenerator mfg = new MolecularFormulaGenerator(builder, minMass, maxMass, mfRange);
            IMolecularFormulaSet mfSet = mfg.GetAllFormulas();
</code>
  </Codes>
  <Codes id="NCDK.Geometries.Alignments.KabschAlignment_Example.cs">
    <code>                var ac1 = new AtomContainer();    // molecule 1
                var ac2 = new AtomContainer();    // molecule 2
                try
                {
                    KabschAlignment sa = new KabschAlignment(ac1.Atoms, ac2.Atoms);

                    sa.Align();
                    Console.Out.WriteLine(sa.RMSD);
                }
                catch (CDKException) { }
</code>
  </Codes>
  <Codes id="NCDK.Geometries.Alignments.KabschAlignment_Example.cs+substructure">
    <code>                AtomContainer ac1 = new AtomContainer();    // whole molecules
                AtomContainer ac2 = new AtomContainer();    // 
                IAtom[] a1 = ac1.Atoms.ToArray();   // some subsets of atoms from the two molecules
                IAtom[] a2 = ac2.Atoms.ToArray();   // 
                try
                {
                    var sa = new KabschAlignment(a1, a2);
                    sa.Align();

                    var cm1 = sa.CenterOfMass;
                    foreach (var a in ac1.Atoms)
                        a.Point3D = a.Point3D.Value - cm1;
                    sa.RotateAtomContainer(ac2);
                    // display the two AtomContainer's
                }
                catch (CDKException) { }
</code>
  </Codes>
  <Codes id="NCDK.Geometries.CIP.CIPTool_Example.cs">
    <code>            IAtom[] ligandAtoms = mol.GetConnectedAtoms(centralAtom).ToArray();
            ITetrahedralChirality tetraStereo = new TetrahedralChirality(centralAtom, ligandAtoms, TetrahedralStereo.AntiClockwise);
            CIPChirality cipChirality = CIPTool.GetCIPChirality(mol, tetraStereo);
</code>
  </Codes>
  <Codes id="NCDK.Geometries.RDFCalculator_Example.cs">
    <code>            RDFCalculator calculator = new RDFCalculator(0.0, 5.0, 0.1, 0.0,
                delegate(IAtom atom, IAtom atom2) { return atom.Charge.Value * atom2.Charge.Value; });
</code>
  </Codes>
  <Codes id="NCDK.Graphs.InChI.InChIGenerator_Example.cs">
    <code>            // Generate factory -  if native code does not load
            InChIGeneratorFactory factory = new InChIGeneratorFactory();
            // Get InChIGenerator
            InChIGenerator gen = factory.GetInChIGenerator(container);

            InChIReturnCode ret = gen.ReturnStatus;
            if (ret == InChIReturnCode.Warning)
            {
                // InChI generated, but with warning message
                Console.WriteLine($"InChI warning: {gen.Message}");
            }
            else if (ret != InChIReturnCode.Ok)
            {
                // InChI generation failed
                throw new CDKException($"InChI failed: {ret.ToString()} [{gen.Message}]");
            }

            string inchi = gen.InChI;
            string auxinfo = gen.AuxInfo;
</code>
  </Codes>
  <Codes id="NCDK.Graphs.InChI.InChIToStructure_Example.cs">
    <code>            // Get InChIToStructure
            InChIToStructure intostruct = InChIToStructure.FromInChI(inchi, ChemObjectBuilder.Instance);

            InChIReturnCode ret = intostruct.ReturnStatus;
            if (ret == InChIReturnCode.Warning)
            {
                // Structure generated, but with warning message
                Console.WriteLine($"InChI warning: {intostruct.Message}");
            }
            else if (ret != InChIReturnCode.Ok)
            {
                // Structure generation failed
                throw new CDKException($"Structure generation failed: {ret.ToString()} [{intostruct.Message}]");
            }             
            IAtomContainer container = intostruct.AtomContainer;
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Invariant.Canon_Example.cs">
    <code>            IAtomContainer m = TestMoleculeFactory.MakeAlphaPinene();
            int[][] g = GraphUtil.ToAdjList(m);

            // obtain canon labelling
            long[] canon_labels = Canon.Label(m, g);

            // obtain symmetry classes
            long[] symmetry_labels = Canon.Symmetry(m, g);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Invariant.ConjugatedPiSystemsDetector_Example.cs+Detect">
    <code>                Atom a0 = new Atom("C"); mol.Atoms.Add(a0);
                Atom a1 = new Atom("C"); mol.Atoms.Add(a1);
                Atom a2 = new Atom("C"); mol.Atoms.Add(a2);
                Atom h1 = new Atom("H"); mol.Atoms.Add(h1);
                Atom h2 = new Atom("H"); mol.Atoms.Add(h2);
                Atom h3 = new Atom("H"); mol.Atoms.Add(h3);
                Atom h4 = new Atom("H"); mol.Atoms.Add(h4);
                Atom h5 = new Atom("H"); mol.Atoms.Add(h5);
                mol.AddBond(a0, a1, BondOrder.Double);
                mol.AddBond(a1, a2, BondOrder.Single);
                mol.AddBond(a0, h1, BondOrder.Single);
                mol.AddBond(a0, h2, BondOrder.Single);
                mol.AddBond(a1, h3, BondOrder.Single);
                mol.AddBond(a2, h4, BondOrder.Single);
                mol.AddBond(a2, h5, BondOrder.Single);
                SingleElectron se = new SingleElectron(a2);
                mol.Add(se);

                var pi_systems = ConjugatedPiSystemsDetector.Detect(mol);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AllCycles_Example.cs">
    <code>using NCDK.RingSearches;
using NCDK.Templates;

namespace NCDK.Graphs
{
    class AllCycles_Example
    {
        public static void Main(string[] args)
        {
            // convert the molecule to adjacency list - may be redundant in future
            IAtomContainer m = TestMoleculeFactory.MakeAlphaPinene();
            int[][] g = GraphUtil.ToAdjList(m);

            // efficient computation/partitioning of the ring systems
            RingSearch rs = new RingSearch(m, g);

            // isolated cycles don't need to be run
            rs.Isolated();

            // process fused systems separately
            foreach (var fused in rs.Fused())
            {
                const int maxDegree = 100;
                // given the fused subgraph, max cycle size is
                // the number of vertices
                AllCycles ac = new AllCycles(GraphUtil.Subgraph(g, fused), fused.Length, maxDegree);
                // cyclic walks
                int[][] paths = ac.GetPaths();
            }
        }
    }
}
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AllPairsShortestPaths_Example.cs">
    <code>                IAtomContainer benzene = TestMoleculeFactory.MakeBenzene();
                AllPairsShortestPaths apsp = new AllPairsShortestPaths(benzene);
                for (int i = 0; i &lt; benzene.Atoms.Count; i++)
                {
                    // only to half the comparisons, we can reverse the
                    // path[] to get all j to i
                    for (int j = i + 1; j &lt; benzene.Atoms.Count; j++)
                    {
                        // reconstruct shortest path from i to j
                        int[] path = apsp.From(i).GetPathTo(j);

                        // reconstruct all shortest paths from i to j
                        int[][] paths = apsp.From(i).GetPathsTo(j);

                        // reconstruct the atoms in the path from i to j
                        IAtom[] atoms = apsp.From(i).GetAtomsTo(j);

                        // access the number of paths from i to j
                        int nPaths = apsp.From(i).GetNPathsTo(j);

                        // access the distance from i to j
                        int distance = apsp.From(i).GetNPathsTo(j);
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AllPairsShortestPaths_Example.cs+From">
    <code>                AllPairsShortestPaths apsp = new AllPairsShortestPaths(benzene);

                // access explicitly
                ShortestPaths sp = apsp.From(0);
                // or chain method calls
                int[] path = apsp.From(0).GetPathTo(5);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AllPairsShortestPaths_Example.cs+From_IAtom">
    <code>                AllPairsShortestPaths apsp = new AllPairsShortestPaths(molecule);
                IAtom start = molecule.Atoms[0];
                IAtom end = molecule.Atoms[1];

                // access explicitly
                ShortestPaths sp = apsp.From(start);
                
                 // or chain the method calls together
                
                 // first path from start to end atom
                 int[] path = apsp.From(start).GetPathTo(end);
                
                 // first atom path from start to end atom
                 IAtom[] atoms = apsp.From(start).GetAtomsTo(end);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AtomContainerAtomPermutor_Example.cs">
    <code>            AtomContainerAtomPermutor permutor = new AtomContainerAtomPermutor(container);
            while (permutor.MoveNext())
            {
                IAtomContainer permutedContainer = permutor.Current;
                // ...
            }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.AtomContainerBondPermutor_Example.cs">
    <code>            AtomContainerBondPermutor permutor = new AtomContainerBondPermutor(container);
            while (permutor.MoveNext())
            {
                IAtomContainer permutedContainer = permutor.Current;
                // ...
            }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ConnectedComponents_Example.cs">
    <code>            int[][] g = GraphUtil.ToAdjList(container);
            ConnectedComponents cc = new ConnectedComponents(g);
            int[] components = cc.GetComponents();
            for (int v = 0; v &lt; g.Length; v++)
                Console.WriteLine(components[v]);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ConnectivityChecker_Example.cs+1">
    <code>            bool isConnected = ConnectivityChecker.IsConnected(container);
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ConnectivityChecker_Example.cs+2">
    <code>            var fragments = ConnectivityChecker.PartitionIntoMolecules(disconnectedContainer);
            int fragmentCount = fragments.Count;
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+AllSimpleFinder">
    <code>                ICycleFinder cf = Cycles.AllSimpleFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // handle error - note it is common that finding all simple cycles in chemical graphs is intractable
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+MCB">
    <code>                ICycleFinder cf = Cycles.AllSimpleFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - MCB should never be intractable
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+Relevant">
    <code>                ICycleFinder cf = Cycles.AllSimpleFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - there may be an exponential number of cycles but this is not currently checked
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+Essential">
    <code>                ICycleFinder cf = Cycles.AllSimpleFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - essential cycles do not check tractability
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+TripletShort">
    <code>                ICycleFinder cf = Cycles.AllSimpleFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - triple short cycles do not check tractability
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+VertexShort">
    <code>                ICycleFinder cf = Cycles.AllSimpleFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - vertex short cycles do not check tractability
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+EdgeShort">
    <code>                ICycleFinder cf = Cycles.AllSimpleFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - edge short cycles do not check tractability
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+CDKAromaticSetFinder">
    <code>                ICycleFinder cf = Cycles.AllSimpleFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - edge short cycles do not check tractability
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+AllOrVertexShortFinder">
    <code>                ICycleFinder cf = Cycles.AllSimpleFinder;
                foreach (var container in containers) 
                {
                    try
                    {
                        Cycles cycles = cf.Find(container);
                        IRingSet rings  = cycles.ToRingSet();
                    } 
                    catch (IntractableException) 
                    {
                        // ignore error - edge short cycles do not check tractability
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+Or6">
    <code>                // all cycles or all cycles size &lt;= 6
                ICycleFinder cf = Cycles.Or(Cycles.AllSimpleFinder, Cycles.GetAllFinder(6));
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+OrARE">
    <code>                // all cycles or relevant or essential
                ICycleFinder cf = Cycles.Or(Cycles.AllSimpleFinder, Cycles.Or(Cycles.RelevantFinder, Cycles.EssentialFinder));
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+FindAll">
    <code>                foreach (var container in containers)
                {
                    try
                    {
                        Cycles cycles = Cycles.FindAll(container);
                        IRingSet rings = cycles.ToRingSet();
                    }
                    catch (IntractableException)
                    {
                        // handle error - note it is common that finding all simple cycles in chemical graphs is intractable
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+FindMCB">
    <code>                        Cycles cycles = Cycles.FindMCB(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+FindSSSR">
    <code>                        Cycles cycles = Cycles.FindSSSR(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+FindRelevant">
    <code>                        Cycles cycles = Cycles.FindRelevant(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+FindEssential">
    <code>                        Cycles cycles = Cycles.FindEssential(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+FindTripletShort">
    <code>                        Cycles cycles = Cycles.FindTripletShort(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+FindVertexShort">
    <code>                        Cycles cycles = Cycles.FindVertexShort(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.Cycles_Example.tt.cs+FindEdgeShort">
    <code>                        Cycles cycles = Cycles.FindEdgeShort(container);
                        IRingSet rings = cycles.ToRingSet();
</code>
  </Codes>
  <Codes id="NCDK.Graphs.GraphUtil_Example.cs+Subgraph">
    <code>            int[][] g = GraphUtil.ToAdjList(naphthalene);
            int[] vs = new int[] { 0, 1, 2, 3, 4, 5 };

            int[][] h = GraphUtil.Subgraph(g, vs);
            // for the vertices in h, the provided 'vs' gives the original index
            for (int v = 0; v &lt; h.Length; v++)
            {
                // vs[v] is 'v' in 'g'
            }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.RelevantCycles_Example.cs">
    <code>                // using NCDK.Graphs.GraphUtil;
                IAtomContainer m = TestMoleculeFactory.MakeAnthracene();

                // compute on the whole graph
                RelevantCycles relevant = new RelevantCycles(ToAdjList(m));

                // it is much faster to compute on the separate ring systems of the molecule
                int[][] graph = ToAdjList(m);
                RingSearch ringSearch = new RingSearch(m, graph);

                // all isolated cycles are relevant
                foreach (int[] isolated in ringSearch.Isolated())
                {
                    int[] path = Cycle(graph, isolated);
                }

                // compute the relevant cycles for each system
                foreach (int[] fused in ringSearch.Fused())
                {
                    int[][] subgraph = Subgraph(graph, fused);
                    RelevantCycles relevantOfSubgraph = new RelevantCycles(subgraph);

                    foreach (int[] path in relevantOfSubgraph.GetPaths())
                    {
                        // convert the sub graph vertices back to the super graph indices
                        for (int i = 0; i &lt; path.Length; i++)
                        {
                            path[i] = fused[path[i]];
                        }
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.RelevantCycles_Example.cs+GetPaths">
    <code>                RelevantCycles relevant = new RelevantCycles(ToAdjList(mol));

                // ensure the number is manageable
                if (relevant.Count() &lt; 100) {
                    foreach (int[] path in relevant.GetPaths())
                    {
                        // process the path
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs">
    <code>                IAtomContainer benzene = TestMoleculeFactory.MakeBenzene();

                IAtom c1 = benzene.Atoms[0];
                IAtom c4 = benzene.Atoms[3];

                // shortest paths from C1
                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // number of paths from C1 to C4
                int nPaths = sp.GetNPathsTo(c4);

                // distance between C1 to C4
                int distance = sp.GetDistanceTo(c4);

                // reconstruct a path to the C4 - determined by storage order
                int[] path = sp.GetPathTo(c4);

                // reconstruct all paths
                int[][] paths = sp.GetPathsTo(c4);
                int[] org = paths[0];  // paths[0] == path
                int[] alt = paths[1];
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetPathTo_int">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // reconstruct first path
                int[] path = sp.GetPathTo(5);

                // check there is only one path
                if (sp.GetNPathsTo(5) == 1)
                {
                    path = sp.GetPathTo(5); // reconstruct the path
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetPathTo_IAtom">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                // reconstruct first path
                int[] path = sp.GetPathTo(end);

                // check there is only one path
                if (sp.GetNPathsTo(end) == 1)
                {
                    path = sp.GetPathTo(end); // reconstruct the path
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetPathsTo_int">
    <code>                int threshold = 20;
                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // reconstruct shortest paths
                int[][] paths = sp.GetPathsTo(5);

                // only reconstruct shortest paths below a threshold
                if (sp.GetNPathsTo(5) &lt; threshold)
                {
                    int[][] path = sp.GetPathsTo(5); // reconstruct shortest paths
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetPathsTo_IAtom">
    <code>                int threshold = 20;
                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                // reconstruct all shortest paths
                int[][] paths = sp.GetPathsTo(end);

                // only reconstruct shortest paths below a threshold
                if (sp.GetNPathsTo(end) &lt; threshold)
                {
                    paths = sp.GetPathsTo(end); // reconstruct shortest paths
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetAtomsTo_int">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);

                // reconstruct a shortest path
                IAtom[] path = sp.GetAtomsTo(5);

                // ensure single shortest path
                if (sp.GetNPathsTo(5) == 1)
                {
                    path = sp.GetAtomsTo(5); // reconstruct shortest path
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetAtomsTo_IAtom">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                // reconstruct a shortest path
                IAtom[] path = sp.GetAtomsTo(end);

                // ensure single shortest path
                if (sp.GetNPathsTo(end) == 1)
                {
                    path = sp.GetAtomsTo(end); // reconstruct shortest path
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetNPathsTo_int">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);

                sp.GetNPathsTo(5); // number of paths

                sp.GetNPathsTo(-1); // returns 0 - there are no paths
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetNPathsTo_IAtom">
    <code>                ShortestPaths sp = new ShortestPaths(benzene, c1);
                IAtom end = benzene.Atoms[3];

                sp.GetNPathsTo(end); // number of paths

                sp.GetNPathsTo(null);           // returns 0 - there are no paths
                sp.GetNPathsTo(new Atom("C"));  // returns 0 - there are no paths
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetDistanceTo_int_1">
    <code>                IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths sp = new ShortestPaths(container, c1); // start = 0

                int n = container.Atoms.Count;

                if (sp.GetDistanceTo(5) &lt; n)
                {
                    // these is a path from 0 to 5
                }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetDistanceTo_int_2">
    <code>                IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths sp = new ShortestPaths(container, c1); // start = 0

                int[] path = sp.GetPathTo(5);
                
                 int start = path[0];
                 int end   = path[sp.GetDistanceTo(5)];                
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetDistanceTo_IAtom_1">
    <code>                 IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths sp = new ShortestPaths(container, c1); // start atom
                IAtom end = container.Atoms[3];

                int n = container.Atoms.Count;
                
                 if( sp.GetDistanceTo(end) &lt; n) {
                     // these is a path from start to end
                 }
</code>
  </Codes>
  <Codes id="NCDK.Graphs.ShortestPaths_Example.cs+GetDistanceTo_IAtom_2">
    <code>                 IAtomContainer container = TestMoleculeFactory.MakeBenzene();
                IAtom c1 = container.Atoms[0];
                ShortestPaths  sp = new ShortestPaths(container, c1); // start atom
                IAtom end = container.Atoms[3];

                IAtom[] atoms = sp.GetAtomsTo(end);
                Console.WriteLine(end == atoms[sp.GetDistanceTo(end)]); // true
</code>
  </Codes>
  <Codes id="NCDK.Groups.AtomDiscretePartitionRefiner_Example.cs+1">
    <code>                IAtomContainer ac = someMolecule; // get an atom container somehow
                AtomDiscretePartitionRefiner refiner = new AtomDiscretePartitionRefiner();
                PermutationGroup autG = refiner.GetAutomorphismGroup(ac);
                foreach (var automorphism in autG.GenerateAll())
                {
                    // do something with the permutation
                }
</code>
  </Codes>
  <Codes id="NCDK.Groups.AtomDiscretePartitionRefiner_Example.cs+2">
    <code>                IAtomContainer ac = someMolecule; // get an atom container somehow
                AtomDiscretePartitionRefiner refiner = new AtomDiscretePartitionRefiner();
                if (refiner.IsCanonical(ac))
                {
                    // do something with the atom container
                }
</code>
  </Codes>
  <Codes id="NCDK.Groups.AtomDiscretePartitionRefiner_Example.cs+3">
    <code>                AtomDiscretePartitionRefiner refiner = new AtomDiscretePartitionRefiner();
                refiner.Refine(ac);
                bool isCanon = refiner.IsCanonical();
                PermutationGroup autG = refiner.GetAutomorphismGroup();
</code>
  </Codes>
  <Codes id="NCDK.Groups.BondDiscretePartitionRefiner_Example.cs+1">
    <code>                IAtomContainer ac = someMolecule; // get an atom container somehow
                BondDiscretePartitionRefiner refiner = new BondDiscretePartitionRefiner();
                PermutationGroup autG = refiner.GetAutomorphismGroup(ac);
                foreach (var automorphism in autG.GenerateAll())
                {
                    // do something with the permutation
                }
</code>
  </Codes>
  <Codes id="NCDK.Groups.BondDiscretePartitionRefiner_Example.cs+2">
    <code>                IAtomContainer ac = someMolecule; // get an atom container somehow
                BondDiscretePartitionRefiner refiner = new BondDiscretePartitionRefiner();
                if (refiner.IsCanonical(ac))
                {
                     // do something with the atom container
                 }
</code>
  </Codes>
  <Codes id="NCDK.Groups.BondDiscretePartitionRefiner_Example.cs+3">
    <code>                BondDiscretePartitionRefiner refiner = new BondDiscretePartitionRefiner();
                refiner.Refine(ac);
                bool isCanon = refiner.IsCanonical();
                PermutationGroup autG = refiner.GetAutomorphismGroup();
</code>
  </Codes>
  <Codes id="NCDK.Groups.PartitionRefinement_Example.cs">
    <code>                IAtomContainerDiscretePartitionRefiner refiner = PartitionRefinement.ForAtoms().Create();
</code>
  </Codes>
  <Codes id="NCDK.Hash.HashGeneratorMaker_Example.cs">
    <code>            // simple
            IMoleculeHashGenerator generator0 = new HashGeneratorMaker().Depth(16)
                                                                       .Elemental()
                                                                       .Molecular();

            // fast
            IMoleculeHashGenerator generator1 = new HashGeneratorMaker().Depth(8)
                                                                       .Elemental()
                                                                       .Isotopic()
                                                                       .Charged()
                                                                       .Orbital()
                                                                       .Molecular();
            // comprehensive
            IMoleculeHashGenerator generator2 = new HashGeneratorMaker().Depth(32)
                                                                       .Elemental()
                                                                       .Isotopic()
                                                                       .Charged()
                                                                       .Chiral()
                                                                       .Perturbed()
                                                                       .Molecular();
</code>
  </Codes>
  <Codes id="NCDK.IO.Iterator.EnumerableMDLConformerReader_Example.cs">
    <code>                string filename = "/Users/rguha/conf2.sdf";
                using (var srm = new FileStream(filename, FileMode.Open))
                {
                    var reader = new EnumerableMDLConformerReader(srm, ChemObjectBuilder.Instance);
                    foreach (var cc in reader)
                    {
                        // do something 
                    }
                }
                // do something with this set of conformers
</code>
  </Codes>
  <Codes id="NCDK.IO.Iterator.EnumerableSDFReader_Example.cs">
    <code>                using (var srm = new FileStream("../zinc-structures/ZINC_subset3_3D_charged_wH_maxmin1000.sdf", FileMode.Open))
                {
                    EnumerableSDFReader reader = new EnumerableSDFReader(srm, ChemObjectBuilder.Instance);
                    foreach (var molecule in reader)
                    {
                        // do something
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.Setting.SettingManager_Example.cs">
    <code>                // create the manager and add a setting
                var manager = new SettingManager&lt;BooleanIOSetting&gt;();
                manager.Add(new BooleanIOSetting("Sample", Importance.Medium, "This is a sample?", "true"));

                // check the setting is present (case insensitive)
                if (manager.Has("sample"))
                {
                    // access requiring multiple lines of code
                    BooleanIOSetting setting = manager["sample"];
                    string v1 = setting.Setting;
                    // single line access (useful for conditional statements)
                    string v2 = manager["sample"].Setting;
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.Setting.SettingManager_Example.cs+Add">
    <code>                var manager = new SettingManager&lt;BooleanIOSetting&gt;();
                BooleanIOSetting setting1 = manager.Add(new BooleanIOSetting("use.3d", importance, some, some));
                BooleanIOSetting setting2 = manager.Add(new BooleanIOSetting("use.3d", importance, some, some));

                // setting1 == setting2 and so changing a field in setting1 will also change the field
                // in setting2
</code>
  </Codes>
  <Codes id="NCDK.IO.Setting.SettingManager_Example.cs+get">
    <code>                var manager = new SettingManager&lt;BooleanIOSetting&gt;();
                manager.Add(new BooleanIOSetting("name", importance, some, some));

                BooleanIOSetting setting1 = manager["Name"]; // okay
                // OptionIOSetting setting2 = manager["Name"]; // failed to compile
</code>
  </Codes>
  <Codes id="NCDK.IO.CMLWriter_Example.cs">
    <code>                using (var cmlwriter = new CMLWriter(new FileStream("molecule.cml", FileMode.Create)))
                {
                    cmlwriter.Write(molecule);
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.FormatFactory_Example.cs">
    <code>                StringReader stringReader = new StringReader("&lt;molecule/&gt;");
                IChemFormat format = new FormatFactory().GuessFormat(stringReader);
</code>
  </Codes>
  <Codes id="NCDK.IO.MDLRXNWriter_Example.cs">
    <code>                using (var writer = new MDLRXNWriter(new FileStream("output.mol", FileMode.Create)))
                {
                    writer.Write(molecule);
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.MDLV2000Writer_Example.cs">
    <code>                using (var writer = new MDLV2000Writer(new FileStream("output.mol", FileMode.Create)))
                {
                    writer.Write((IAtomContainer)molecule);
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.MDLV2000Writer_Example.cs+listener">
    <code>                var customSettings = new NameValueCollection
                {
                    ["ForceWriteAs2DCoordinates"] = "true"
                };
                var listener = new PropertiesListener(customSettings);
                writer.Listeners.Add(listener);
</code>
  </Codes>
  <Codes id="NCDK.IO.NCDKSourceCodeWriter_Example.cs">
    <code>                using (var stringWriter = new StringWriter())
                {
                    using (var writer = new NCDKSourceCodeWriter(stringWriter))
                    {
                        writer.Write(molecule);
                    }
                    Console.Out.Write(stringWriter.ToString());
                }
</code>
  </Codes>
  <Codes id="NCDK.IO.ReaderFactory_Example.cs">
    <code>            using (StringReader stringReader = new StringReader("&lt;molecule/&gt;"))
            using (var reader = new ReaderFactory().CreateReader(stringReader))
            {
                //
            }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Matchers.QueryAtomContainer_Example.cs+Create1">
    <code>            // [nH]1ccc(=O)cc1 =&gt; n1:c:c:c(=O):c:c:1
            QueryAtomContainer.Create(mol,
                ExprType.AliphaticElement,
                ExprType.AromaticElement,
                ExprType.SingleOrAromatic,
                ExprType.AliphaticOrder,
                ExprType.Stereochemistry);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Matchers.QueryAtomContainer_Example.cs+Create2">
    <code>            // [nH]1ccc(=O)cc1 =&gt; [nD2]1:[cD2]:[cD2]:[cD2](=[OD1]):[cD2]:[cD2]:1
            QueryAtomContainer.Create(mol,
                ExprType.AliphaticElement,
                ExprType.AromaticElement,
                ExprType.Degree,
                ExprType.SingleOrAromatic,
                ExprType.AliphaticOrder);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Matchers.QueryAtomContainer_Example.cs+Create3">
    <code>            // [nH]1ccc(=O)cc1 =&gt; [nx2+0]1:[cx2+0]:[cx2+0]:[cx2+0](=[O&amp;x0+0]):[cx2+0]:[cx2+0]:1
            // IMPORTANT! use Cycles.MarkRingAtomsAndBonds(mol) to set ring status
            QueryAtomContainer.Create(mol,
                ExprType.AliphaticElement,
                ExprType.AromaticElement,
                ExprType.FormalCharge,
                ExprType.Isotope,
                ExprType.RingBondCount,
                ExprType.SingleOrAromatic,
                ExprType.AliphaticOrder);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Matchers.QueryAtomContainer_Example.cs+Create4">
    <code>            // [nH]1ccc(=O)cc1 =&gt; [0n+0]1:[0c+0]:[0c+0]:[0c+0](=[O+0]):[0c+0]:[0c+0]:1
            QueryAtomContainer.Create(mol,
                ExprType.AliphaticElement,
                ExprType.AromaticElement,
                ExprType.FormalCharge,
                ExprType.Isotope,
                ExprType.RingBondCount,
                ExprType.SingleOrAromatic,
                ExprType.AliphaticOrder);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.ComponentFilter_Example.cs">
    <code>            // grouping is actually set by SMARTS parser but this shows how it's stored
            query.SetProperty(ComponentFilter.Key, grouping);

            IAtomContainer target = someTarget;
            Pattern pattern = somePattern; // create pattern for query

            // filter for mappings which respect component grouping in the query
            var filter = new ComponentFilter(query, target);
            pattern.MatchAll(target).Where(filter.Apply);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.DfPattern_Example.cs">
    <code>            var pattern = DfPattern.CreateSubstructureFinder(query);
            // has match?
            if (pattern.Matches(mol))
            {
            }
            // get lazy mapping iterator
            foreach (var atom in mol.Atoms)
            {
                if (pattern.MatchesRoot(atom))
                {
                }
            }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.DfState_Example.cs">
    <code>            var state = new DfState(query);
            state.SetMol(mol);
            int count = 0;
            foreach (int[] amap in state)
            {
                // amap is permutation of query to molecule
                ++count;
            }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+1">
    <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                Mappings mappings = Pattern.CreateSubstructureFinder(query).MatchAll(target);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+enum_mappings">
    <code>                foreach (int[] p in mappings)
                {
                    for (int i = 0; i &lt; p.Length; i++)
                    {
                        // query.Atoms[i] is mapped to target.Atoms[p[i]];
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+stereochemistry">
    <code>                foreach (int[] p in mappings.GetStereochemistry())
                {
                    // ...
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+unique_matches">
    <code>                foreach (int[] p in mappings.GetUniqueAtoms())
                {
                    // ...
                }

                foreach (int[] p in mappings.GetUniqueBonds())
                {
                    // ...
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+toarray">
    <code>                    int[][] ps = mappings.ToArray();
                    foreach (int[] p in ps)
                    {
                        // ...
                    }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+limit_matches">
    <code>                    // first ten matches
                    foreach (int[] p in mappings.Limit(10))
                    {
                        // ...
                    }

                    // first 10 unique matches
                    foreach (int[] p in mappings.GetUniqueAtoms().Limit(10))
                    {
                        // ...
                    }

                    // ensure we don't waste memory and only 'fix' up to 100 unique matches
                    int[][] ps = mappings.GetUniqueAtoms().Limit(100).ToArray();
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+all">
    <code>                // first 100 unique matches
                Mappings m1 = mappings.GetUniqueAtoms().Limit(100);

                // unique matches in the first 100 matches
                Mappings m2 = mappings.Limit(100).GetUniqueAtoms();

                // first 10 unique matches in the first 100 matches
                Mappings m3 = mappings.Limit(100).GetUniqueAtoms().Limit(10);

                // number of unique atom matches
                int n1 = mappings.CountUnique();

                // number of unique atom matches with correct stereochemistry
                int n2 = mappings.GetStereochemistry().CountUnique();
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+Filter">
    <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                // obtain only the mappings where the first atom in the query is
                // mapped to the first atom in the target
                Mappings mappings = Pattern.CreateSubstructureFinder(query)
                    .MatchAll(target)
                    .Filter(input =&gt; input[0] == 0);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+GetMapping">
    <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                Mappings mappings = Pattern.CreateSubstructureFinder(query).MatchAll(target);
                // a string that indicates the mapping of atom elements and numbers
                IEnumerable&lt;string&gt; strs = mappings.GetMapping(
                    input =&gt;
                    {
                        StringBuilder sb = new StringBuilder();
                        for (int i = 0; i &lt; input.Length; i++)
                        {
                            if (i &gt; 0) sb.Append(", ");
                            sb.Append(query.Atoms[i])
                               .Append(i + 1)
                               .Append(" -&gt; ")
                               .Append(target.Atoms[input[i]])
                               .Append(input[i] + 1);
                        }
                        return sb.ToString();
                    });
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToArray1">
    <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                Pattern pat = Pattern.CreateSubstructureFinder(query);

                // lazily iterator
                foreach (int[] mapping in pat.MatchAll(target))
                {
                    // logic...
                }

                int[][] mappings = pat.MatchAll(target).ToArray();

                // same as lazy iterator but we now can refer to and parse 'mappings'
                // to other methods without regenerating the graph match
                foreach (int[] mapping in mappings)
                {
                    // logic...
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToArray2">
    <code>                IAtomContainer query = queryStructure;
                IAtomContainer target = targetStructure;

                Pattern pat = Pattern.CreateSubstructureFinder(query);

                // array of the first 5 unique atom mappings
                int[][] mappings = pat.MatchAll(target)
                                      .GetUniqueAtoms()
                                      .Limit(5)
                                      .ToArray();
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToAtomMap">
    <code>                foreach (var map in mappings.ToAtomMaps())
                {
                    foreach (var e in map)
                    {
                        IAtom queryAtom = e.Key;
                        IAtom targetAtom = e.Value;
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToBondMap">
    <code>                foreach (var map in mappings.ToBondMaps())
                {
                    foreach (var e in map)
                    {
                        IBond queryBond = e.Key;
                        IBond targetBond = e.Value;
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToAtomBondMap">
    <code>                foreach (var map in mappings.ToAtomBondMaps())
                {
                    foreach (var e in map)
                    {
                        IChemObject queryObj = e.Key;
                        IChemObject targetObj = e.Value;
                    }
                    IAtom matchedAtom = (IAtom)map[query.Atoms[i]];
                    IBond matchedBond = (IBond)map[query.Bonds[i]];
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToChemObjects">
    <code>                foreach (var obj in mappings.ToChemObjects())
                {
                    if (obj is IAtom)
                    {
                        // this atom was 'hit' by the pattern
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+ToSubstructures">
    <code>                IAtomContainer target = targetStructure;
                Mappings mappings = someMappings;
                foreach (var mol in mappings.ToSubstructures())
                {
                    foreach (var atom in mol.Atoms)
                        target.Contains(atom); // always true
                    foreach (var atom in target.Atoms)
                        mol.Contains(atom); // not always true
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Mappings_Example.cs+AtLeast">
    <code>                Mappings mappings = someMappings;

                if (mappings.AtLeast(5))
                {
                    // set bit flag etc.
                }

                // are the at least 5 unique matches?
                if (mappings.GetUniqueAtoms().AtLeast(5))
                {
                    // set bit etc.
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Pattern_Example.cs+Match">
    <code>                Pattern pattern = createPattern; // create pattern
                foreach (var m in ms)
                {
                    int[] mapping = pattern.Match(m);
                    if (mapping.Length &gt; 0)
                    {
                        // found mapping!
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Pattern_Example.cs+Matches">
    <code>                Pattern pattern = createPattern; // create pattern
                foreach (var m in ms)
                {
                    if (pattern.Matches(m))
                    {
                        // found mapping!
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Pattern_Example.cs+MatchAll1">
    <code>                Pattern pattern = Pattern.CreateSubstructureFinder(query);
                foreach (var m in ms)
                {
                    foreach (int[] mapping in pattern.MatchAll(m))
                    {
                        // found mapping
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Pattern_Example.cs+MatchAll2">
    <code>                // find only the first 5 mappings and store them in an array
                Pattern pattern = Pattern.CreateSubstructureFinder(query);
                int[][] mappings = pattern.MatchAll(target)
                                          .Limit(5)
                                          .ToArray();
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.StereoMatch_Example.cs">
    <code>                StereoMatch f = new StereoMatch(query, target);
                Mappings mappings = something; // from subgraph isomorphism etc.
                Mappings stereoMappings = mappings.Filter(f.Apply);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Ullmann_Example.cs+1">
    <code>                IAtomContainer query = queryStructure;
                Pattern pattern = Ullmann.CreateSubstructureFinder(query);

                int hits = 0;
                foreach (var m in ms)
                    if (pattern.Matches(m))
                        hits++;
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.Ullmann_Example.cs+2">
    <code>                IAtomContainer query = queryStructure;
                Pattern pattern = Ullmann.CreateSubstructureFinder(query);

                int hits = 0;
                foreach (var m in ms)
                {
                    int[] match = pattern.Match(m);
                    if (match.Length &gt; 0)
                        hits++;
                }
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.UniqueAtomMatches_Example.cs">
    <code>                Pattern pattern = Ullmann.CreateSubstructureFinder(query);
                pattern.MatchAll(target).Filter(new UniqueAtomMatches().Apply);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.UniqueBondMatches_Example.cs">
    <code>                Pattern pattern = Ullmann.CreateSubstructureFinder(query);
                var unique = pattern.MatchAll(target).Filter(new UniqueBondMatches(queryGraph).Apply);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.UniversalIsomorphismTester_Example.cs">
    <code>            SmilesParser sp = new SmilesParser();
            IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C"); // acetic acid anhydride
            IAtomContainer SMILESquery = sp.ParseSmiles("CC"); // ethylene
            IQueryAtomContainer query = QueryAtomContainerCreator.CreateBasicQueryContainer(SMILESquery);
            bool isSubstructure = universalIsomorphismTester.IsSubgraph(atomContainer, query);
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.VentoFoggia_Example.cs+1">
    <code>                IAtomContainer query = queryStructure;
                Pattern pattern = VentoFoggia.CreateSubstructureFinder(query);

                int hits = 0;
                foreach (var m in ms)
                    if (pattern.Matches(m))
                        hits++;
</code>
  </Codes>
  <Codes id="NCDK.Isomorphisms.VentoFoggia_Example.cs+2">
    <code>                IAtomContainer query = queryStructure;
                Pattern pattern = VentoFoggia.CreateSubstructureFinder(query);

                int hits = 0;
                foreach (var m in ms)
                {
                    int[] match = pattern.Match(m);
                    if (match.Length &gt; 0)
                        hits++;
                }
</code>
  </Codes>
  <Codes id="NCDK.Layout.HydrogenPlacer_Example.cs">
    <code>            IAtomContainer container = TestMoleculeFactory.MakeAlphaPinene();
            HydrogenPlacer hydrogenPlacer = new HydrogenPlacer();
            hydrogenPlacer.PlaceHydrogens2D(container, 1.5);
</code>
  </Codes>
  <Codes id="NCDK.Layout.StructureDiagramGenerator_Example.cs">
    <code>            StructureDiagramGenerator sdg = new StructureDiagramGenerator();
             sdg.Molecule = someMolecule;
             sdg.GenerateCoordinates();
            IAtomContainer layedOutMol = sdg.Molecule;
</code>
  </Codes>
  <Codes id="NCDK.Modelings.Builder3D.ModelBuilder3D_Example.cs">
    <code>            ModelBuilder3D mb3d = ModelBuilder3D.GetInstance();
            IAtomContainer molecule = mb3d.Generate3DCoordinates(mol, false);
</code>
  </Codes>
  <Codes id="NCDK.Pharmacophore.PharmacophoreMatcher_Example.cs">
    <code>            QueryAtomContainer query = new QueryAtomContainer();

            PharmacophoreQueryAtom o = new PharmacophoreQueryAtom("D", "[OX1]");
            PharmacophoreQueryAtom n1 = new PharmacophoreQueryAtom("A", "[N]");
            PharmacophoreQueryAtom n2 = new PharmacophoreQueryAtom("A", "[N]");

            query.Atoms.Add(o);
            query.Atoms.Add(n1);
            query.Atoms.Add(n2);

            PharmacophoreQueryBond b1 = new PharmacophoreQueryBond(o, n1, 4.0, 4.5);
            PharmacophoreQueryBond b2 = new PharmacophoreQueryBond(o, n2, 4.0, 5.0);
            PharmacophoreQueryBond b3 = new PharmacophoreQueryBond(n1, n2, 5.4, 5.8);

            query.Bonds.Add(b1);
            query.Bonds.Add(b2);
            query.Bonds.Add(b3);

            string filename = "C:/Users/rguha/pcore1.sdf";
            using (var srm = new FileStream(filename, FileMode.Open))
            {
                foreach (var conformers in new EnumerableMDLConformerReader(srm))
                {
                    bool firstTime = true;
                    foreach (var conf in conformers)
                    {
                        bool status;
                        if (firstTime)
                        {
                            status = matcher.Matches(conf, true);
                            firstTime = false;
                        }
                        else status = matcher.Matches(conf, false);
                        if (status)
                        {
                            // OK, matched. Do something
                        }
                    }
</code>
  </Codes>
  <Codes id="NCDK.Pharmacophore.PharmacophoreUtils_Example.cs+ReadPharmacophoreDefinitions">
    <code>            using (var srm = new FileStream("mydefs.xml", FileMode.Open))
            {
                IList&lt;PharmacophoreQuery&gt; defs = PharmacophoreUtils.ReadPharmacophoreDefinitions(srm);
                Console.Out.WriteLine("Number of definitions = " + defs.Count);
                for (int i = 0; i &lt; defs.Count; i++) {
                    Console.Out.WriteLine($"Desc: {defs[i].GetProperty&lt;string&gt;("description")}");
                }
            }
</code>
  </Codes>
  <Codes id="NCDK.Renderers.Elements.MarkedElement_Example.cs">
    <code>            atom.SetProperty(MarkedElement.IdKey, "my_atm_id");
            atom.SetProperty(MarkedElement.ClassKey, "h_donor");
            atom.SetProperty(MarkedElement.ClassKey, "h_acceptor");
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.AllRingsFinder_Example.cs">
    <code>                AllRingsFinder arf = new AllRingsFinder();
                foreach (var m in ms)
                {
                    try
                    {
                        IRingSet rs = arf.FindAllRings(m);
                    }
                    catch (CDKException)
                    {
                        // molecule was too complex, handle error
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.AllRingsFinder_Example.cs+UsingThreshold">
    <code>                // using static NCDK.RingSearches.AllRingsFinder.Threshold;
                AllRingsFinder arf = AllRingsFinder.UsingThreshold(Threshold.PubChem99);
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.RingSearch_Example.cs">
    <code>                // construct the search for a given molecule, if an adjacency list
                // representation (int[][]) is available this can be passed to the
                // constructor for improved performance
                IAtomContainer container = TestMoleculeFactory.MakeAlphaPinene();
                RingSearch ringSearch = new RingSearch(container);

                // indices of cyclic vertices
                int[] cyclic = ringSearch.Cyclic();

                // iterate over fused systems (atom indices)
                foreach (int[] fused in ringSearch.Fused())
                {
                    // ...
                }

                // iterate over isolated rings (atom indices)
                foreach (int[] isolated in ringSearch.Isolated())
                {
                    // ...
                }

                // convenience methods for getting the fragments
                IAtomContainer fragments = ringSearch.RingFragments();

                foreach (IAtomContainer fragment in ringSearch.FusedRingFragments())
                {
                    // ...
                }
                foreach (IAtomContainer fragment in ringSearch.IsolatedRingFragments())
                {
                    // ...
                }
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.RingSearch_Example.cs+Cyclic">
    <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                RingSearch ringSearch = new RingSearch(mol);
                foreach (var atom in mol.Atoms)
                {
                    if (ringSearch.Cyclic(atom))
                    {
                        // ...
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.RingSearch_Example.cs+Cyclic_int">
    <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                RingSearch tester = new RingSearch(mol);

                int n = mol.Atoms.Count;
                for (int i = 0; i &lt; n; i++)
                {
                    if (tester.Cyclic(i))
                    {
                        // ...
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.RingSearch_Example.cs+Isolated">
    <code>                IAtomContainer biphenyl = TestMoleculeFactory.MakeBiphenyl();
                RingSearch ringSearch = new RingSearch(biphenyl);

                int[][] isolated = ringSearch.Isolated();
                Console.WriteLine(isolated.Length); // 2 isolated rings in biphenyl
                Console.WriteLine(isolated[0].Length); // 6 vertices in one benzene
                Console.WriteLine(isolated[1].Length); // 6 vertices in the other benzene
</code>
  </Codes>
  <Codes id="NCDK.RingSearches.RingSearch_Example.cs+Fused">
    <code>                IAtomContainer mol = new Smiles.SmilesParser().ParseSmiles("c1cc(cc2cc(ccc12)C3C4CC34)C6CC5CCC6(C5)");
                RingSearch ringSearch = new RingSearch(mol);
                
                int[][] fused = ringSearch.Fused();
                Console.WriteLine(fused.Length); // e.g. 3 separate fused ring systems
                Console.WriteLine(fused[0].Length); // e.g. 10 vertices in the first system
                Console.WriteLine(fused[1].Length); // e.g. 4 vertices in the second system
                Console.WriteLine(fused[2].Length); // e.g. 7 vertices in the third system
</code>
  </Codes>
  <Codes id="NCDK.Signatures.MoleculeSignature_Example.cs">
    <code>             IAtomContainer diamantane = TestMoleculeFactory.MakeBenzene();
             MoleculeSignature moleculeSignature = new MoleculeSignature(diamantane);
             string canonicalSignature = moleculeSignature.ToCanonicalString();
            
             // to get the orbits of this molecule
            IList&lt;Orbit&gt; orbits = moleculeSignature.CalculateOrbits();
            
             // and to get the height-2 signature string of just atom 5:
             string hSignatureForAtom5 = moleculeSignature.SignatureStringForVertex(5, 2);
</code>
  </Codes>
  <Codes id="NCDK.Similarity.Tanimoto_Example.cs+1">
    <code>            BitArray fingerprint1 = fingerprinter.GetBitFingerprint(molecule1).AsBitSet();
            BitArray fingerprint2 = fingerprinter.GetBitFingerprint(molecule2).AsBitSet();
            double tanimoto_coefficient = Tanimoto.Calculate(fingerprint1, fingerprint2);
</code>
  </Codes>
  <Codes id="NCDK.SMARTS.SmartsFragmentExtractor_Example.cs">
    <code>            var smipar = new SmilesParser();

            IAtomContainer mol = smipar.ParseSmiles("[nH]1ccc2c1cccc2");
            var subsmarts = new SmartsFragmentExtractor(mol);

            string smarts;
            // smarts=[nH1v3X3+0][cH1v4X3+0][cH1v4X3+0][cH0v4X3+0]
            // hits  =1
            smarts = subsmarts.Generate(new int[]{ 0, 1, 3, 4 });

            subsmarts.SetMode(SubstructureSelectionMode.JCompoundMapper);
            // smarts=n(ccc(a)a)a
            // hits  = 0 - one of the 'a' atoms needs to match the nitrogen
            smarts = subsmarts.Generate(new int[]{ 0, 1, 3, 4 });
</code>
  </Codes>
  <Codes id="NCDK.SMARTS.Smarts_Example.cs+1">
    <code>            if (Smarts.Parse(mol, "[aD3]a-a([aD3])[aD3]"))
            {
                var smarts = Smarts.Generate(mol);
            }
</code>
  </Codes>
  <Codes id="NCDK.SMARTS.Smarts_Example.cs+GenerateAtom">
    <code>                var expr = new Expr(ExprType.Degree, 4).And(
                           new Expr(ExprType.IsAromatic));
                var aExpr = Smarts.GenerateAtom(expr);
                // aExpr = "[D4a]"
</code>
  </Codes>
  <Codes id="NCDK.SMARTS.Smarts_Example.cs+GenerateBond">
    <code>                var expr = new Expr(ExprType.True);
                var bExpr = Smarts.GenerateBond(expr);
                // // bExpr='~'
</code>
  </Codes>
  <Codes id="NCDK.SMARTS.Smarts_Example.cs+Generate">
    <code>                var qatom1 = new QueryAtom();
                var qatom2 = new QueryAtom();
                var qbond = new QueryBond();
                qatom1.Expression = new Expr(ExprType.IsAromatic);
                qatom2.Expression = new Expr(ExprType.IsAromatic);
                qbond.Expression = new Expr(ExprType.IsAliphatic);
                qbond.SetAtoms(new IAtom[] { qatom1, qatom2 });
                mol.Atoms.Add(qatom1);
                mol.Atoms.Add(qatom2);
                mol.Bonds.Add(qbond);
                var smartsStr = Smarts.Generate(mol);
                // smartsStr = 'a!:a'
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.Parser.SMARTSParser_Example.cs+1">
    <code>            SmilesParser sp = new SmilesParser();
             IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C");
             QueryAtomContainer query = SMARTSParser.Parse("C*C");
             bool queryMatch = universalIsomorphismTester.IsSubgraph(atomContainer, query);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.Parser.SMARTSParser_Example.cs+2">
    <code>             SMARTSParser parser = new SMARTSParser(new StringReader("C*C"));
             ASTStart start = parser.Start();
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.Parser.SmartsQueryVisitor_Example.cs+1">
    <code>            SMARTSParser parser = new SMARTSParser(new StringReader("C*C"));
            ASTStart ast = parser.Start();
            SmartsQueryVisitor visitor = new SmartsQueryVisitor();
            QueryAtomContainer query = (QueryAtomContainer)visitor.Visit(ast, null);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.SmartsPattern_Example.cs+1">
    <code>                Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC");

                foreach (var ac in acs)
                {
                    if (ptrn.Matches(ac))
                    {
                        // 'ac' contains the pattern
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.SmartsPattern_Example.cs+2">
    <code>                Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC");

                foreach (var ac in acs)
                {
                    nUniqueHits += ptrn.MatchAll(ac).CountUnique();
                }
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.SmartsPattern_Example.cs+MatchAll">
    <code>                 Pattern ptrn = SmartsPattern.Create("O[C@?H](C)CC");
                 int nUniqueHits = 0;
                
                 foreach (var ac in acs) {
                   nUniqueHits += ptrn.MatchAll(ac).CountUnique();
                 }
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.SMARTSQueryTool_Example.cs">
    <code>                SmilesParser sp = new SmilesParser();
                IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C");
                SMARTSQueryTool querytool = new SMARTSQueryTool("O=CO");
                bool status = querytool.Matches(atomContainer);
                if (status)
                {
                    int nmatch = querytool.MatchesCount;
                    var mappings = querytool.GetMatchingAtoms();
                    foreach (var atomIndices in mappings)
                    {
                        // do something
                    }
                }
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SMARTS.SMARTSQueryTool_Example.cs+SetAromaticity">
    <code>                SMARTSQueryTool sqt = new SMARTSQueryTool(someSmartsPattern);
                sqt.SetAromaticity(new Aromaticity(ElectronDonation.CDKModel, Cycles.CDKAromaticSetFinder));
                foreach (var molecule in molecules)
                {
                    // CDK Aromatic model needs atom types
                    AtomContainerManipulator.PercieveAtomTypesAndConfigureAtoms(molecule);
                    sqt.Matches(molecule);
                }
</code>
  </Codes>
  <Codes id="NCDK.Smiles.CDKToBeam_Example.cs">
    <code>using NCDK.Templates;

namespace NCDK.Smiles
{
    class CDKToBeam_Example
    {
        void Main()
        {
            IAtomContainer m = TestMoleculeFactory.MakeBenzene();

            // converter is thread-safe and can be used by multiple threads
            CDKToBeam c2g = new CDKToBeam();
            Beam.Graph g = c2g.ToBeamGraph(m);

            // get the SMILES notation from the Beam graph
            string smi = g.ToSmiles();
        }
    }
}
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+SmiFlavors">
    <code>                SmilesGenerator smigen = new SmilesGenerator(SmiFlavors.Isomeric);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+SmiFlavor_Isomeric">
    <code>                SmilesGenerator smigen = new SmilesGenerator(SmiFlavors.Stereo | SmiFlavors.AtomicMass);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+1">
    <code>                    IAtomContainer ethanol = TestMoleculeFactory.MakeEthanol();
                    sg = new SmilesGenerator(SmiFlavors.Generic);
                    smi = sg.Create(ethanol); // CCO, C(C)O, C(O)C, or OCC

                    sg = SmilesGenerator.Unique;
                    smi = sg.Create(ethanol); // only CCO
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+2">
    <code>                    IAtomContainer benzene = TestMoleculeFactory.MakeBenzene();

                    // 'benzene' molecule has no arom flags, we always get Kekulé output
                    sg = new SmilesGenerator(SmiFlavors.Generic);
                    smi = sg.Create(benzene); // C1=CC=CC=C1

                    sg = new SmilesGenerator(SmiFlavors.Generic | SmiFlavors.UseAromaticSymbols);
                    smi = sg.Create(benzene); // C1=CC=CC=C1 flags not set!

                    // Note, in practice we'd use an aromaticity algorithm
                    foreach (IAtom a in benzene.Atoms)
                        a.IsAromatic = true;
                    foreach (IBond b in benzene.Bonds)
                        b.IsAromatic = true;

                    // 'benzene' molecule now has arom flags, we always get aromatic SMILES if we request it
                    sg = new SmilesGenerator(SmiFlavors.Generic);
                    smi = sg.Create(benzene); // C1=CC=CC=C1

                    sg = new SmilesGenerator(SmiFlavors.Generic | SmiFlavors.UseAromaticSymbols);
                    smi = sg.Create(benzene); // c1ccccc1
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+4">
    <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                SmilesGenerator sg = new SmilesGenerator(SmiFlavors.Generic);

                int n = mol.Atoms.Count;
                int[] order = new int[n];

                // the order array is filled up as the SMILES is generated
                string smi = sg.Create(mol, order);

                // load the coordinates array such that they are in the order the atoms
                // are read when parsing the SMILES
                Vector2[] coords = new Vector2[mol.Atoms.Count];
                for (int i = 0; i &lt; coords.Length; i++)
                    coords[order[i]] = mol.Atoms[i].Point2D.Value;

                // SMILES string suffixed by the coordinates
                string smi2d = smi + " " + Arrays.ToJavaString(coords);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+Aromatic">
    <code>                SmilesGenerator smigen = new SmilesGenerator(SmiFlavors.UseAromaticSymbols);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+WithAtomClasses">
    <code>                SmilesGenerator smigen = new SmilesGenerator(SmiFlavors.AtomAtomMap);
                smigen.CreateSMILES(container); // C[CH2:4]O second atom has class = 4
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+WithAtomClasses">
    <code>                IAtomContainer container = TestMoleculeFactory.MakeAlphaPinene();
                SmilesGenerator smilesGen = SmilesGenerator.Unique.WithAtomClasses();
                smilesGen.CreateSMILES(container); // C[CH2:4]O second atom has class = 4
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+Create_IAtomContainer_int">
    <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                SmilesGenerator sg = new SmilesGenerator();

                int n = mol.Atoms.Count;
                int[] order = new int[n];

                // the order array is filled up as the SMILES is generated
                string smi = sg.Create(mol, order);

                // load the coordinates array such that they are in the order the atoms
                // are read when parsing the SMILES
                Vector2[] coords = new Vector2[mol.Atoms.Count];
                for (int i = 0; i &lt; coords.Length; i++)
                    coords[order[i]] = mol.Atoms[i].Point2D.Value;

                // SMILES string suffixed by the coordinates
                string smi2d = smi + " " + Arrays.ToJavaString(coords);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesGenerator_Example.cs+Create_IAtomContainer_int_int">
    <code>                IAtomContainer mol = TestMoleculeFactory.MakeAlphaPinene();
                SmilesGenerator sg = new SmilesGenerator();

                int n = mol.Atoms.Count;
                int[] order = new int[n];

                // the order array is filled up as the SMILES is generated
                string smi = sg.Create(mol, order);

                // load the coordinates array such that they are in the order the atoms
                // are read when parsing the SMILES
                Vector2[] coords = new Vector2[mol.Atoms.Count];
                for (int i = 0; i &lt; coords.Length; i++)
                    coords[order[i]] = container.Atoms[i].Point2D.Value;

                // SMILES string suffixed by the coordinates
                string smi2d = smi + " " + Arrays.ToJavaString(coords);
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesParser_Example.cs+1">
    <code>                SmilesParser sp = new SmilesParser();
                IAtomContainer m = sp.ParseSmiles("c1[cH:5]cccc1");
                var c1 = m.Atoms[1].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // 5
                var c2 = m.Atoms[2].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // null
</code>
  </Codes>
  <Codes id="NCDK.Smiles.SmilesParser_Example.cs+2">
    <code>                SmilesParser sp = new SmilesParser();
                IAtomContainer m = sp.ParseSmiles("c1[cH:5]cccc1");
                var c1 = m.Atoms[1].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // 5
                var c2 = m.Atoms[2].GetProperty&lt;int&gt;(CDKPropertyName.AtomAtomMapping); // null
</code>
  </Codes>
  <Codes id="NCDK.SMSD.Algorithms.RGraphs.CDKMCS_Example.cs">
    <code>            SmilesParser sp = new SmilesParser();
            IAtomContainer atomContainer = sp.ParseSmiles("CC(=O)OC(=O)C"); // acetic acid anhydride
            IAtomContainer SMILESquery = sp.ParseSmiles("CC"); // acetic acid anhydride
            IQueryAtomContainer query = QueryAtomContainerCreator.CreateBasicQueryContainer(SMILESquery);
            bool isSubstructure = CDKMCS.IsSubgraph(atomContainer, query, true);
</code>
  </Codes>
  <Codes id="NCDK.SMSD.Isomorphism_Example.cs+1">
    <code>                SmilesParser sp = new SmilesParser();
                // Benzene
                IAtomContainer A1 = sp.ParseSmiles("C1=CC=CC=C1");
                // Napthalene
                IAtomContainer A2 = sp.ParseSmiles("C1=CC2=C(C=C1)C=CC=C2");
                //Turbo mode search
                //Bond Sensitive is set true
                Isomorphism comparison = new Isomorphism(Algorithm.SubStructure, true);
                // set molecules, remove hydrogens, clean and configure molecule
                comparison.Init(A1, A2, true, true);
                // set chemical filter true
                comparison.SetChemFilters(false, false, false);
                if (comparison.IsSubgraph())
                {
                    //Get similarity score
                    Console.Out.WriteLine("Tanimoto coefficient:  " + comparison.GetTanimotoSimilarity());
                    Console.Out.WriteLine("A1 is a subgraph of A2:  " + comparison.IsSubgraph());
                    //Get Modified AtomContainer
                    IAtomContainer Mol1 = comparison.ReactantMolecule;
                    IAtomContainer Mol2 = comparison.ProductMolecule;
                    // Print the mapping between molecules
                    Console.Out.WriteLine(" Mappings: ");
                    foreach (var mapping in comparison.GetFirstMapping())
                    {
                        Console.Out.WriteLine((mapping.Key + 1) + " " + (mapping.Value + 1));

                        IAtom eAtom = Mol1.Atoms[mapping.Key];
                        IAtom pAtom = Mol2.Atoms[mapping.Value];
                        Console.Out.WriteLine(eAtom.Symbol + " " + pAtom.Symbol);
                    }
                    Console.Out.WriteLine("");
                }
</code>
  </Codes>
  <Codes id="NCDK.SMSD.Isomorphism_Example.cs+2">
    <code>                SmilesParser sp = new SmilesParser();
                // Benzene
                IAtomContainer A1 = sp.ParseSmiles("C1=CC=CC=C1");
                // Napthalene
                IAtomContainer A2 = sp.ParseSmiles("C1=CC2=C(C=C1)C=CC=C2");
                //{ 0: Default Isomorphism Algorithm, 1: MCSPlus Algorithm, 2: VFLibMCS Algorithm, 3: CDKMCS Algorithm}
                //Bond Sensitive is set true
                Isomorphism comparison = new Isomorphism(Algorithm.Default, true);
                // set molecules, remove hydrogens, clean and configure molecule
                comparison.Init(A1, A2, true, true);
                // set chemical filter true
                comparison.SetChemFilters(true, true, true);

                //Get similarity score
                Console.Out.WriteLine("Tanimoto coefficient:  " + comparison.GetTanimotoSimilarity());
                Console.Out.WriteLine("A1 is a subgraph of A2:  " + comparison.IsSubgraph());
                //Get Modified AtomContainer
                IAtomContainer Mol1 = comparison.ReactantMolecule;
                IAtomContainer Mol2 = comparison.ProductMolecule;
                // Print the mapping between molecules
                Console.Out.WriteLine(" Mappings: ");
                foreach (var mapping in comparison.GetFirstMapping())
                {
                    Console.Out.WriteLine((mapping.Key + 1) + " " + (mapping.Value + 1));

                    IAtom eAtom = Mol1.Atoms[mapping.Key];
                    IAtom pAtom = Mol2.Atoms[mapping.Value];
                    Console.Out.WriteLine(eAtom.Symbol + " " + pAtom.Symbol);
                }
                Console.Out.WriteLine("");
</code>
  </Codes>
  <Codes id="NCDK.Stereo.Stereocenters_Example.cs+Of">
    <code>            IAtomContainer container = someContainer;
            Stereocenters centers = Stereocenters.Of(container);
            for (int i = 0; i &lt; container.Atoms.Count; i++)
            {
                if (centers.IsStereocenter(i))
                {

                }
            }
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs">
    <code>                IAtomContainer container = someMolecule;
                StereoElementFactory stereo = StereoElementFactory.Using2DCoordinates(container).InterpretProjections(Projection.Haworth);

                // set the elements replacing any existing elements 
                container.SetStereoElements(stereo.CreateAll());

                // adding elements individually is also possible but existing elements are 
                // are not removed 
                foreach (var element in stereo.CreateAll())
                    container.StereoElements.Add(element);
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs+CreateTetrahedral_int">
    <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                for (int v = 0; v &lt; container.Atoms.Count; v++)
                {
                    // ... verify v is a stereo atom ...
                    ITetrahedralChirality element = factory.CreateTetrahedral(v, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs+CreateTetrahedral_IAtom">
    <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                foreach (var atom in container.Atoms)
                {
                    // ... verify atom is a stereo atom ...
                    ITetrahedralChirality element = factory.CreateTetrahedral(atom, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs+CreateGeometric_IBond">
    <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                foreach (var bond in container.Bonds)
                {
                    if (bond.Order != BondOrder.Double)
                        continue;
                    // ... verify bond is a stereo bond...
                    IDoubleBondStereochemistry element = factory.CreateGeometric(bond, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs+CreateExtendedTetrahedral">
    <code>                StereoElementFactory factory = someFactory; // 2D/3D
                IAtomContainer container = someMolecule; // container

                for (int v = 0; v &lt; container.Atoms.Count; v++)
                {
                    // ... verify v is a stereo atom ...
                    ExtendedTetrahedral element = factory.CreateExtendedTetrahedral(v, null);
                    if (element != null)
                        container.StereoElements.Add(element);
                }
</code>
  </Codes>
  <Codes id="NCDK.Stereo.StereoElementFactory_Example.cs+InterpretProjections">
    <code>                StereoElementFactory factory =
                    StereoElementFactory.Using2DCoordinates(container)
                        .InterpretProjections(Projection.Fischer, Projection.Haworth);
</code>
  </Codes>
  <Codes id="NCDK.Tools.AtomContainerManipulator_Example.cs+1">
    <code>                AtomContainerManipulator.ReplaceAtomByAtom(container, atom1, atom2);
</code>
  </Codes>
  <Codes id="NCDK.Tools.AtomContainerManipulator_Example.cs+SetSingleOrDoubleFlags">
    <code>            SmilesParser parser = new SmilesParser(ChemObjectBuilder.Instance, false);

            IAtomContainer biphenyl = parser.ParseSmiles("c1cccc(c1)c1ccccc1");

            AtomContainerManipulator.SetSingleOrDoubleFlags(biphenyl);
</code>
  </Codes>
  <Codes id="NCDK.Tools.CDKHydrogenAdder_Example.cs+1">
    <code>                IAtomContainer methane = new AtomContainer();
                IAtom carbon = new Atom("C");
                methane.Atoms.Add(carbon);
                CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.GetInstance();
                foreach (var atom in methane.Atoms)
                {
                    IAtomType type = matcher.FindMatchingAtomType(methane, atom);
                    AtomTypeManipulator.Configure(atom, type);
                }
                var adder = CDK.HydrogenAdder;
                adder.AddImplicitHydrogens(methane);
</code>
  </Codes>
  <Codes id="NCDK.Tools.CDKHydrogenAdder_Example.cs+2">
    <code>                IAtomContainer ethane = new AtomContainer();
                IAtom carbon1 = new Atom("C");
                IAtom carbon2 = new Atom("C");
                ethane.Atoms.Add(carbon1);
                ethane.Atoms.Add(carbon2);
                CDKAtomTypeMatcher matcher = CDKAtomTypeMatcher.GetInstance();
                IAtomType type = matcher.FindMatchingAtomType(ethane, carbon1);
                AtomTypeManipulator.Configure(carbon1, type);
                var adder = CDK.HydrogenAdder;
                adder.AddImplicitHydrogens(ethane, carbon1);
</code>
  </Codes>
  <Codes id="NCDK.Tools.DataFeatures_Example.cs+1">
    <code>            var features = new XYZFormat().SupportedDataFeatures;
            bool has3DCoords = (features &amp; DataFeatures.Has3DCoordinates) == DataFeatures.Has3DCoordinates;
</code>
  </Codes>
  <Codes id="NCDK.Tools.StructureResonanceGenerator_Example.cs+1">
    <code>            StructureResonanceGenerator sRG = new StructureResonanceGenerator();
            IChemObjectSet&lt;IAtomContainer&gt; setOf = sRG.GetContainers(molecule);
</code>
  </Codes>
  <Codes id="NCDK.Tools.StructureResonanceGenerator_Example.cs+2">
    <code>            molecule.Atoms[0].IsReactiveCenter = true;
</code>
  </Codes>
  <Codes id="NCDK.TT.Element_Example.cs">
    <code>                IsotopeFactory f = XMLIsotopeFactory.Instance;
                ChemicalElement e1 = f.GetElement("C");
                ChemicalElement e2 = f.GetElement(12);
</code>
  </Codes>
  <Codes id="NCDK.TT.Element_Example.cs+AtomicNumber">
    <code>                IAtom element = new Atom("C");
                IsotopeFactory f = XMLIsotopeFactory.Instance;
                f.Configure(element);
</code>
  </Codes>
  <Codes id="NCDK.TT.Isotope_Example.cs+1">
    <code>                Isotope carbon = new Isotope("C", 13);
</code>
  </Codes>
  <Codes id="NCDK.TT.Isotope_Example.cs+2">
    <code>                // make deuterium
                Isotope carbon = new Isotope(ChemicalElement.H, 2, 2.01410179, 100.0);
</code>
  </Codes>
  <Codes id="NCDK.TT.Isotope_Example.cs+Abundance">
    <code>                IAtom atom = new Atom();
                Isotope isotope = new Isotope("C", 13);
                XMLIsotopeFactory f = XMLIsotopeFactory.Instance;
                f.Configure(atom, isotope);
</code>
  </Codes>
  <Codes id="NCDK.Chem_Example.cs">
    <code>namespace NCDK
{
    using System;
    using System.IO;
    using System.IO.Compression;
    using System.Linq;

    class Chem_Example
    {
        static void Main(string[] args)
        {
            var toluene = Chem.MolFromSmiles("Cc1ccccc1");
            var mol1 = Chem.MolFromFile("Data/input.mol");
            var stringWithMolData = new StreamReader("Data/input.mol").ReadToEnd();
            var mol2 = Chem.MolFromMolBlock(stringWithMolData);

            using (var suppl = Chem.SDMolSupplier("Data/5ht3ligs.sdf"))
            {
                Console.WriteLine(suppl.Count);
                foreach (var mol in suppl)
                {
                    if (mol == null)
                        continue;
                    Console.WriteLine(mol.Atoms.Count);
                }
                Console.WriteLine(suppl[0].Atoms.Count);
            }

            using (var fsuppl = Chem.ForwardSDMolSupplier(new FileStream("Data/5ht3ligs.sdf", FileMode.Open)))
            {
                foreach (var mol in fsuppl)
                {
                    if (mol == null)
                        continue;
                    Console.WriteLine(mol.Atoms.Count);
                }
            }

            using (var gzsuppl = Chem.ForwardSDMolSupplier(
                new GZipStream(
                    new FileStream("Data/actives_5ht3.sdf.gz", FileMode.Open), 
                    CompressionMode.Decompress)))
            {
                Console.WriteLine(gzsuppl.Count(x =&gt; x != null));
            }
        }
    }
}
</code>
  </Codes>
  <Codes id="NCDK.ConformerContainer_Example.cs">
    <code>            var reader = new EnumerableMDLConformerReader(
                new FileStream(filename, FileMode.Open),
                ChemObjectBuilder.Instance);
            foreach (ConformerContainer cc in reader)
            {
                foreach (var conformer in cc)
                {
                    // do something with each conformer
                }
            }
</code>
  </Codes>
  <Codes id="NCDK.IAtomContainer_Example.cs">
    <code>            foreach (var bond in atomContainer.Bonds)
            {
                // do something
            }
</code>
  </Codes>
  <Codes id="NCDK.ISingleElectron_Example.cs">
    <code>                AtomContainer radical = new AtomContainer();
                Atom carbon = new Atom("C");
                carbon.ImplicitHydrogenCount = 3;
                radical.Add(new SingleElectron(carbon));
</code>
  </Codes>
  <Codes id="NCDK.Property_Example.cs">
    <code>            IAtom atom = new Atom("C");
            atom.SetProperty("number", 1); // set an integer property
            {
                // access the property and cast to an int
                int number = atom.GetProperty&lt;int&gt;("number");
            }
            {
                // the type cannot be checked and so...
                try
                {
                    string number = atom.GetProperty&lt;string&gt;("number");
                }
                catch (InvalidCastException)
                {
                    Console.WriteLine($"{nameof(InvalidCastException)} is thrown");
                }
            }
</code>
  </Codes>
</Comments>



