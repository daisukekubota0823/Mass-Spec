<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ assembly name="System.Xml" #>
<#@ import namespace="System.Xml" #>
<#@ output extension=".cs" #>
<#
    XmlDocument doc = new XmlDocument();
    doc.Load(Host.ResolvePath("MsdialLipidModel.xml"));
    XmlElement root = doc.DocumentElement;
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED. DO NOT CHANGE IT.
// CHANGE THE .tt FILE INSTEAD.
// </auto-generated>

using CompMs.Common.Enum;
using CompMs.Common.FormulaGenerator.DataObj;
using System.Linq;
using System.Text.RegularExpressions;

namespace CompMs.Common.Lipidomics
{
<# foreach (XmlNode lipidNode in root.ChildNodes) { #>
<#   if (lipidNode.SelectNodes("Parsers[@IsEnabled=\"False\"]").Count > 0) {
         continue;
     } #>

    public class <#= lipidNode["Name"].InnerText #>LipidParser : ILipidParser {
        public string Target { get; } = "<#= lipidNode["Abbreviation"].InnerText #>";

<#     if (lipidNode.SelectNodes("Chains/Capacity").Count > 0 && lipidNode.SelectNodes("Chains/Ether").Count > 0) { #>
        private static readonly TotalChainParser chainsParser = TotalChainParser.BuildLysoEtherParser(<#= lipidNode["Chains"]["Total"].InnerText #>, <#= lipidNode["Chains"]["Capacity"].InnerText #>);
<#     } #>
<#     else if (lipidNode.SelectNodes("Chains/Ether").Count > 0) { #>
        private static readonly TotalChainParser chainsParser = TotalChainParser.BuildEtherParser(<#= lipidNode["Chains"]["Total"].InnerText #>);
<#     } #>
<#     else if (lipidNode.SelectNodes("Chains/Ceramide").Count > 0) { #>
        private static readonly TotalChainParser chainsParser = TotalChainParser.BuildCeramideParser(<#= lipidNode["Chains"]["Total"].InnerText #>);
<#     } #>
<#     else if (lipidNode.SelectNodes("Chains/Capacity").Count > 0) { #>
        private static readonly TotalChainParser chainsParser = TotalChainParser.BuildSpeciesLevelParser(<#= lipidNode["Chains"]["Total"].InnerText #>, <#= lipidNode["Chains"]["Capacity"].InnerText #>);
<#     } #>
<#     else { #>
        private static readonly TotalChainParser chainsParser = TotalChainParser.BuildParser(<#= lipidNode["Chains"]["Total"].InnerText #>);
<#     } #>
        public static readonly string Pattern = $"^<#= lipidNode["Abbreviation"].InnerText #>\\s*(?<sn>{chainsParser.Pattern})$";
        private static readonly Regex pattern = new Regex(Pattern, RegexOptions.Compiled);

        private static readonly double Skelton = new[]
        {
<#     foreach (XmlElement e in lipidNode["Skelton"].ChildNodes) { #>
            MassDiffDictionary.<#= e.Name #>Mass<#= e.IsEmpty ? string.Empty : " * " + e.InnerText #>,
<#     } #>
        }.Sum();

        public ILipid Parse(string lipidStr) {
            var match = pattern.Match(lipidStr);
            if (match.Success) {
                var group = match.Groups;
                var chains = chainsParser.Parse(group["sn"].Value);
<#     if (lipidNode.SelectNodes("LbmClasses/LbmClass[@Oxidized=\"True\"]").Count > 0){ #>
                if (chains.OxidizedCount > 0)
                {
                    return new Lipid(LbmClass.<#= lipidNode.SelectSingleNode("LbmClasses/LbmClass[@Oxidized=\"True\"]").InnerText #>, Skelton + chains.Mass, chains);
                }
<#     } #>
<#     if (lipidNode.SelectNodes("LbmClasses/LbmClass[not(@Oxidized)]").Count > 0){ #>
                return new Lipid(LbmClass.<#= lipidNode.SelectSingleNode("LbmClasses/LbmClass[not(@Oxidized)]").InnerText #>, Skelton + chains.Mass, chains);
<#     } #>
            }
            return null;
        }
	}
<# } #>
}